import 'package:cloud_firestore/cloud_firestore.dart' hide Order;
import '../models/order.dart';
import '../models/cart_item.dart';
import 'firestore_service.dart';
import 'product_inventory_service.dart';

class OrderService {
  static const String _collection = 'orders';
  
  // Create a new order
  static Future<String> createOrder(Order order) async {
    try {
      final data = order.toMap();
      data.remove('id'); // Remove ID as it will be generated by Firestore
      
      return await FirestoreService.addDocument(
        collection: _collection,
        data: data,
        documentId: order.id.isNotEmpty ? order.id : null,
      );
    } catch (e) {
      throw Exception('Failed to create order: ${e.toString()}');
    }
  }
  
  // Get an order by ID
  static Future<Order?> getOrder(String orderId) async {
    try {
      final doc = await FirestoreService.getDocument(
        collection: _collection,
        documentId: orderId,
      );
      
      if (doc.exists && doc.data() != null) {
        return Order.fromMap(doc.data()!, doc.id);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get order: ${e.toString()}');
    }
  }
  
  // Get all orders
  static Future<List<Order>> getAllOrders() async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .orderBy('dateTime', descending: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Order.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get all orders: ${e.toString()}');
    }
  }
  
  // Get orders by customer ID
  static Future<List<Order>> getOrdersByCustomer(String customerId) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('customerId', isEqualTo: customerId)
          .orderBy('dateTime', descending: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Order.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get orders by customer: ${e.toString()}');
    }
  }
  
  // Get orders by status
  static Future<List<Order>> getOrdersByStatus(String status) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('status', isEqualTo: status)
          .orderBy('dateTime', descending: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Order.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get orders by status: ${e.toString()}');
    }
  }
  
  // Get orders by date range
  static Future<List<Order>> getOrdersByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('dateTime', 
              isGreaterThanOrEqualTo: startDate.millisecondsSinceEpoch)
          .where('dateTime', 
              isLessThanOrEqualTo: endDate.millisecondsSinceEpoch)
          .orderBy('dateTime', descending: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Order.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get orders by date range: ${e.toString()}');
    }
  }
  
  // Update an order
  static Future<void> updateOrder(String orderId, Order order) async {
    try {
      final data = order.toMap();
      data.remove('id'); // Remove ID as it shouldn't be updated
      data.remove('createdAt'); // Don't update creation time
      
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: orderId,
        data: data,
      );
    } catch (e) {
      throw Exception('Failed to update order: ${e.toString()}');
    }
  }
  
  // Update order status
  static Future<void> updateOrderStatus(String orderId, String status) async {
    try {
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: orderId,
        data: {
          'status': status,
          'updatedAt': FieldValue.serverTimestamp(),
        },
      );
    } catch (e) {
      throw Exception('Failed to update order status: ${e.toString()}');
    }
  }

  // Cancel an order and restore stock
  static Future<void> cancelOrder(String orderId) async {
    try {
      // Get the order first to check its current status and items
      final order = await getOrder(orderId);
      if (order == null) {
        throw Exception('Order not found');
      }
      
      // Check if order can be cancelled
      if (order.status == 'Cancelled') {
        throw Exception('Order is already cancelled');
      }
      
      if (order.status == 'Completed' || order.status == 'Delivered') {
        throw Exception('Cannot cancel a completed or delivered order');
      }

      // Restore stock for all items in the order
      await ProductInventoryService.restoreOrderStock(
        order.items,
        reason: 'Order #${order.id} cancelled - stock restored'
      );

      // Update order status to cancelled
      await updateOrderStatus(orderId, 'Cancelled');
      
    } catch (e) {
      throw Exception('Failed to cancel order: ${e.toString()}');
    }
  }
  
  // Add item to order
  static Future<void> addItemToOrder(String orderId, CartItem item) async {
    try {
      await FirestoreService.runTransaction((transaction) async {
        final orderRef = FirebaseFirestore.instance
            .collection(_collection)
            .doc(orderId);
        
        final orderDoc = await transaction.get(orderRef);
        if (!orderDoc.exists) {
          throw Exception('Order not found');
        }
        
        final orderData = orderDoc.data()!;
        final currentItems = (orderData['items'] as List<dynamic>? ?? [])
            .map((item) => CartItem.fromMap(item as Map<String, dynamic>))
            .toList();
        
        // Check if item already exists, if so, update quantity
        final existingItemIndex = currentItems.indexWhere(
          (cartItem) => cartItem.productId == item.productId,
        );
        
        if (existingItemIndex != -1) {
          currentItems[existingItemIndex].quantity += item.quantity;
        } else {
          currentItems.add(item);
        }
        
        // Recalculate subtotal
        final newSubtotal = currentItems.fold<double>(
          0.0, (sum, cartItem) => sum + cartItem.totalPrice,
        );
        
        transaction.update(orderRef, {
          'items': currentItems.map((cartItem) => cartItem.toMap()).toList(),
          'subtotal': newSubtotal,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      });
    } catch (e) {
      throw Exception('Failed to add item to order: ${e.toString()}');
    }
  }
  
  // Remove item from order
  static Future<void> removeItemFromOrder(String orderId, String productId) async {
    try {
      await FirestoreService.runTransaction((transaction) async {
        final orderRef = FirebaseFirestore.instance
            .collection(_collection)
            .doc(orderId);
        
        final orderDoc = await transaction.get(orderRef);
        if (!orderDoc.exists) {
          throw Exception('Order not found');
        }
        
        final orderData = orderDoc.data()!;
        final currentItems = (orderData['items'] as List<dynamic>? ?? [])
            .map((item) => CartItem.fromMap(item as Map<String, dynamic>))
            .toList();
        
        // Remove the item
        currentItems.removeWhere((item) => item.productId == productId);
        
        // Recalculate subtotal
        final newSubtotal = currentItems.fold<double>(
          0.0, (sum, cartItem) => sum + cartItem.totalPrice,
        );
        
        transaction.update(orderRef, {
          'items': currentItems.map((cartItem) => cartItem.toMap()).toList(),
          'subtotal': newSubtotal,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      });
    } catch (e) {
      throw Exception('Failed to remove item from order: ${e.toString()}');
    }
  }
  
  // Delete an order
  static Future<void> deleteOrder(String orderId) async {
    try {
      await FirestoreService.deleteDocument(
        collection: _collection,
        documentId: orderId,
      );
    } catch (e) {
      throw Exception('Failed to delete order: ${e.toString()}');
    }
  }
  
  // Stream orders for real-time updates
  static Stream<List<Order>> streamOrders() {
    try {
      return FirestoreService.streamCollection(
        collection: _collection,
        query: FirebaseFirestore.instance
            .collection(_collection)
            .orderBy('dateTime', descending: true),
      ).map((querySnapshot) =>
          querySnapshot.docs
              .map((doc) => Order.fromMap(doc.data(), doc.id))
              .toList()
      );
    } catch (e) {
      throw Exception('Failed to stream orders: ${e.toString()}');
    }
  }
  
  // Stream orders by customer for real-time updates
  static Stream<List<Order>> streamOrdersByCustomer(String customerId) {
    try {
      return FirestoreService.streamCollection(
        collection: _collection,
        query: FirebaseFirestore.instance
            .collection(_collection)
            .where('customerId', isEqualTo: customerId)
            .orderBy('dateTime', descending: true),
      ).map((querySnapshot) =>
          querySnapshot.docs
              .map((doc) => Order.fromMap(doc.data(), doc.id))
              .toList()
      );
    } catch (e) {
      throw Exception('Failed to stream orders by customer: ${e.toString()}');
    }
  }
  
  // Stream order by ID for real-time updates
  static Stream<Order?> streamOrder(String orderId) {
    try {
      return FirestoreService.streamDocument(
        collection: _collection,
        documentId: orderId,
      ).map((doc) {
        if (doc.exists && doc.data() != null) {
          return Order.fromMap(doc.data()!, doc.id);
        }
        return null;
      });
    } catch (e) {
      throw Exception('Failed to stream order: ${e.toString()}');
    }
  }
  
  // Get order statistics
  static Future<Map<String, dynamic>> getOrderStatistics() async {
    try {
      final allOrders = await getAllOrders();
      
      final totalOrders = allOrders.length;
      final totalRevenue = allOrders.fold<double>(
        0.0, (sum, order) => sum + order.total,
      );
      final averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0.0;
      
      final statusCounts = <String, int>{};
      for (final order in allOrders) {
        statusCounts[order.status] = (statusCounts[order.status] ?? 0) + 1;
      }
      
      return {
        'totalOrders': totalOrders,
        'totalRevenue': totalRevenue,
        'averageOrderValue': averageOrderValue,
        'statusCounts': statusCounts,
      };
    } catch (e) {
      throw Exception('Failed to get order statistics: ${e.toString()}');
    }
  }
}
