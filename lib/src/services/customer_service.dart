import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/customer.dart';
import 'firestore_service.dart';

class CustomerService {
  static const String _collection = 'customers';
  
  // Create a new customer profile
  static Future<String> createCustomer(Customer customer) async {
    try {
      final data = customer.toMap();
      data.remove('id'); // Remove ID as it will be generated by Firestore
      
      return await FirestoreService.addDocument(
        collection: _collection,
        data: data,
        documentId: customer.id.isNotEmpty ? customer.id : null,
      );
    } catch (e) {
      throw Exception('Failed to create customer: ${e.toString()}');
    }
  }
  
  // Get a customer by ID
  static Future<Customer?> getCustomer(String customerId) async {
    try {
      final doc = await FirestoreService.getDocument(
        collection: _collection,
        documentId: customerId,
      );
      
      if (doc.exists && doc.data() != null) {
        return Customer.fromMap(doc.data()!, doc.id);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get customer: ${e.toString()}');
    }
  }
  
  // Get a customer by email
  static Future<Customer?> getCustomerByEmail(String email) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('email', isEqualTo: email)
          .limit(1);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      if (querySnapshot.docs.isNotEmpty) {
        final doc = querySnapshot.docs.first;
        return Customer.fromMap(doc.data(), doc.id);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get customer by email: ${e.toString()}');
    }
  }
  
  // Get all customers
  static Future<List<Customer>> getAllCustomers() async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('isActive', isEqualTo: true)
          .orderBy('displayName');
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Customer.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get all customers: ${e.toString()}');
    }
  }
  
  // Update a customer
  static Future<void> updateCustomer(String customerId, Customer customer) async {
    try {
      final data = customer.toMap();
      data.remove('id'); // Remove ID as it shouldn't be updated
      data.remove('createdAt'); // Don't update creation time
      
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: customerId,
        data: data,
      );
    } catch (e) {
      throw Exception('Failed to update customer: ${e.toString()}');
    }
  }
  
  // Update customer profile
  static Future<void> updateCustomerProfile({
    required String customerId,
    String? displayName,
    String? phoneNumber,
    String? address,
    DateTime? dateOfBirth,
    String? profileImageUrl,
    Map<String, dynamic>? preferences,
  }) async {
    try {
      final Map<String, dynamic> data = {};
      
      if (displayName != null) data['displayName'] = displayName;
      if (phoneNumber != null) data['phoneNumber'] = phoneNumber;
      if (address != null) data['address'] = address;
      if (dateOfBirth != null) data['dateOfBirth'] = dateOfBirth.millisecondsSinceEpoch;
      if (profileImageUrl != null) data['profileImageUrl'] = profileImageUrl;
      if (preferences != null) data['preferences'] = preferences;
      
      if (data.isNotEmpty) {
        await FirestoreService.updateDocument(
          collection: _collection,
          documentId: customerId,
          data: data,
        );
      }
    } catch (e) {
      throw Exception('Failed to update customer profile: ${e.toString()}');
    }
  }
  
  // Update customer preferences
  static Future<void> updateCustomerPreferences(
    String customerId,
    Map<String, dynamic> preferences,
  ) async {
    try {
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: customerId,
        data: {'preferences': preferences},
      );
    } catch (e) {
      throw Exception('Failed to update customer preferences: ${e.toString()}');
    }
  }
  
  // Deactivate a customer (soft delete)
  static Future<void> deactivateCustomer(String customerId) async {
    try {
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: customerId,
        data: {'isActive': false},
      );
    } catch (e) {
      throw Exception('Failed to deactivate customer: ${e.toString()}');
    }
  }
  
  // Delete a customer (hard delete)
  static Future<void> deleteCustomer(String customerId) async {
    try {
      await FirestoreService.deleteDocument(
        collection: _collection,
        documentId: customerId,
      );
    } catch (e) {
      throw Exception('Failed to delete customer: ${e.toString()}');
    }
  }
  
  // Search customers by name or email
  static Future<List<Customer>> searchCustomers(String searchTerm) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('isActive', isEqualTo: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      // Filter results on client side for better search capability
      final allCustomers = querySnapshot.docs
          .map((doc) => Customer.fromMap(doc.data(), doc.id))
          .toList();
      
      return allCustomers.where((customer) =>
          customer.displayName.toLowerCase().contains(searchTerm.toLowerCase()) ||
          customer.email.toLowerCase().contains(searchTerm.toLowerCase())
      ).toList();
    } catch (e) {
      throw Exception('Failed to search customers: ${e.toString()}');
    }
  }
  
  // Stream customers for real-time updates
  static Stream<List<Customer>> streamCustomers() {
    try {
      return FirestoreService.streamCollection(
        collection: _collection,
        query: FirebaseFirestore.instance
            .collection(_collection)
            .where('isActive', isEqualTo: true)
            .orderBy('displayName'),
      ).map((querySnapshot) =>
          querySnapshot.docs
              .map((doc) => Customer.fromMap(doc.data(), doc.id))
              .toList()
      );
    } catch (e) {
      throw Exception('Failed to stream customers: ${e.toString()}');
    }
  }
  
  // Stream customer by ID for real-time updates
  static Stream<Customer?> streamCustomer(String customerId) {
    try {
      return FirestoreService.streamDocument(
        collection: _collection,
        documentId: customerId,
      ).map((doc) {
        if (doc.exists && doc.data() != null) {
          return Customer.fromMap(doc.data()!, doc.id);
        }
        return null;
      });
    } catch (e) {
      throw Exception('Failed to stream customer: ${e.toString()}');
    }
  }
  
  // Get customer statistics
  static Future<Map<String, dynamic>> getCustomerStatistics() async {
    try {
      final allCustomers = await getAllCustomers();
      
      final totalCustomers = allCustomers.length;
      final todaySignups = allCustomers.where((customer) {
        if (customer.createdAt == null) return false;
        final today = DateTime.now();
        final customerDate = customer.createdAt!;
        return customerDate.year == today.year &&
               customerDate.month == today.month &&
               customerDate.day == today.day;
      }).length;
      
      return {
        'totalCustomers': totalCustomers,
        'todaySignups': todaySignups,
      };
    } catch (e) {
      throw Exception('Failed to get customer statistics: ${e.toString()}');
    }
  }
}
