import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/product.dart';
import 'firestore_service.dart';

class ProductService {
  static const String _collection = 'products';
  
  // Create a new product
  static Future<String> createProduct(Product product) async {
    try {
      final data = product.toMap();
      data.remove('id'); // Remove ID as it will be generated by Firestore
      
      return await FirestoreService.addDocument(
        collection: _collection,
        data: data,
        documentId: product.id.isNotEmpty ? product.id : null,
      );
    } catch (e) {
      throw Exception('Failed to create product: ${e.toString()}');
    }
  }
  
  // Get a product by ID
  static Future<Product?> getProduct(String productId) async {
    try {
      final doc = await FirestoreService.getDocument(
        collection: _collection,
        documentId: productId,
      );
      
      if (doc.exists && doc.data() != null) {
        return Product.fromMap(doc.data()!, doc.id);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get product: ${e.toString()}');
    }
  }
  
  // Get all products
  static Future<List<Product>> getAllProducts() async {
    try {
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
      );
      
      return querySnapshot.docs
          .map((doc) => Product.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get all products: ${e.toString()}');
    }
  }
  
  // Get products by category
  static Future<List<Product>> getProductsByCategory(String category) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('category', isEqualTo: category)
          .where('isActive', isEqualTo: true);
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Product.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get products by category: ${e.toString()}');
    }
  }
  
  // Get active products
  static Future<List<Product>> getActiveProducts() async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('isActive', isEqualTo: true)
          .orderBy('name');
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      return querySnapshot.docs
          .map((doc) => Product.fromMap(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw Exception('Failed to get active products: ${e.toString()}');
    }
  }
  
  // Update a product
  static Future<void> updateProduct(String productId, Product product) async {
    try {
      final data = product.toMap();
      data.remove('id'); // Remove ID as it shouldn't be updated
      data.remove('createdAt'); // Don't update creation time
      
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: productId,
        data: data,
      );
    } catch (e) {
      throw Exception('Failed to update product: ${e.toString()}');
    }
  }
  
  // Update product stock
  static Future<void> updateProductStock(String productId, int newStock) async {
    try {
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: productId,
        data: {'stockQuantity': newStock},
      );
    } catch (e) {
      throw Exception('Failed to update product stock: ${e.toString()}');
    }
  }
  
  // Deactivate a product (soft delete)
  static Future<void> deactivateProduct(String productId) async {
    try {
      await FirestoreService.updateDocument(
        collection: _collection,
        documentId: productId,
        data: {'isActive': false},
      );
    } catch (e) {
      throw Exception('Failed to deactivate product: ${e.toString()}');
    }
  }
  
  // Delete a product (hard delete)
  static Future<void> deleteProduct(String productId) async {
    try {
      await FirestoreService.deleteDocument(
        collection: _collection,
        documentId: productId,
      );
    } catch (e) {
      throw Exception('Failed to delete product: ${e.toString()}');
    }
  }
  
  // Search products by name
  static Future<List<Product>> searchProducts(String searchTerm) async {
    try {
      final query = FirebaseFirestore.instance
          .collection(_collection)
          .where('isActive', isEqualTo: true)
          .orderBy('name');
      
      final querySnapshot = await FirestoreService.getCollection(
        collection: _collection,
        query: query,
      );
      
      // Filter results on client side for better search capability
      final allProducts = querySnapshot.docs
          .map((doc) => Product.fromMap(doc.data(), doc.id))
          .toList();
      
      return allProducts.where((product) =>
          product.name.toLowerCase().contains(searchTerm.toLowerCase()) ||
          product.description.toLowerCase().contains(searchTerm.toLowerCase()) ||
          product.category.toLowerCase().contains(searchTerm.toLowerCase())
      ).toList();
    } catch (e) {
      throw Exception('Failed to search products: ${e.toString()}');
    }
  }
  
  // Stream products for real-time updates
  static Stream<List<Product>> streamProducts() {
    try {
      return FirestoreService.streamCollection(
        collection: _collection,
        query: FirebaseFirestore.instance
            .collection(_collection)
            .where('isActive', isEqualTo: true)
            .orderBy('name'),
      ).map((querySnapshot) =>
          querySnapshot.docs
              .map((doc) => Product.fromMap(doc.data(), doc.id))
              .toList()
      );
    } catch (e) {
      throw Exception('Failed to stream products: ${e.toString()}');
    }
  }
  
  // Stream product by ID for real-time updates
  static Stream<Product?> streamProduct(String productId) {
    try {
      return FirestoreService.streamDocument(
        collection: _collection,
        documentId: productId,
      ).map((doc) {
        if (doc.exists && doc.data() != null) {
          return Product.fromMap(doc.data()!, doc.id);
        }
        return null;
      });
    } catch (e) {
      throw Exception('Failed to stream product: ${e.toString()}');
    }
  }
  
  // Batch update multiple products
  static Future<void> batchUpdateProducts(Map<String, Product> products) async {
    try {
      final batch = FirestoreService.getBatch();
      
      products.forEach((productId, product) {
        final data = product.toMap();
        data.remove('id');
        data.remove('createdAt');
        
        final docRef = FirebaseFirestore.instance
            .collection(_collection)
            .doc(productId);
        batch.update(docRef, data);
      });
      
      await batch.commit();
    } catch (e) {
      throw Exception('Failed to batch update products: ${e.toString()}');
    }
  }
}
